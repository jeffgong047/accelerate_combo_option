
Generating frontier for markets:   0%|                                                                      | 0/20 [00:00<?, ?it/s]
There are 25 buy orders and 25 sell orders
#####Generating combinatorial/book/STOCK_2_SEED_2_book_AAPL_MSFT.npy with size 50 and noise 0.015625#####
Starting async computation for iteration 0
> /common/home/hg343/Research/accelerate_combo_option/src/combo_stock_frontier_data_preprocessor_forked.py(158)<module>()
-> market = Market(pd.concat([opt_buy_book_df, opt_sell_book_df], ignore_index=False),mechanism_solver=mechanism_solver_combo)
> /common/home/hg343/Research/accelerate_combo_option/src/combo_stock_frontier_data_preprocessor_forked.py(159)<module>()
-> is_match, profit = market.check_match()
Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,
             9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
           dtype='int64') Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,
             9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
           dtype='int64')
> /common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py(188)mechanism_solver_combo()
-> assert len(set(buy_book_index) & set(sell_book_index)) == 0, "buy and sell book index should not have any shared index"
176  	def mechanism_solver_combo(orders : pd.DataFrame, offset : bool = True, debug=0):
177  	    '''
178  	    orders: pandas dataframe contains bid and ask orders; specify whether code requires standarizing this variable
179  	    offset: whether to offset the price by the offset value
180  	    debug: whether to debug
181  	    '''
182  	    buy_orders = orders.where(orders['transaction_type'] == 1)
183  	    sell_orders = orders.where(orders['transaction_type'] == 0)
184  	    buy_book_index = buy_orders.index
185  	    sell_book_index = sell_orders.index
186  	    print(buy_book_index, sell_book_index)
187  	    breakpoint()
188  ->	    assert len(set(buy_book_index) & set(sell_book_index)) == 0, "buy and sell book index should not have any shared index"
189  	    # Extract liquidity values before converting to numpy arrays
190  	    buy_liquidity = None
191  	    sell_liquidity = None
192  	    if 'liquidity' in buy_orders.columns:
193  	        buy_liquidity = buy_orders['liquidity'].values
194  	    if 'liquidity' in sell_orders.columns:
195  	        sell_liquidity = sell_orders['liquidity'].values
196  	    #
197  	    option_columns = [col for col in buy_orders.columns if col.startwith('option')]
198  	    option_columns.sort()
199  	    remaining_columns = ['C=Call, P=Put',
200  	                    'Strike Price of the Option Times 1000',
201  	                    'transaction_type',
202  	                    'B/A_price']
203  	    sorted_columns_order = option_columns + remaining_columns
204  	    opt_buy_book = buy_orders[sorted_columns_order].to_numpy()
205  	    opt_sell_book = sell_orders[sorted_columns_order].to_numpy()
206  	    num_buy, num_sell, num_stock = len(opt_buy_book), len(opt_sell_book), len(opt_buy_book[0])-4
207  	
208  	    # Add initial constraints
209  	    f_constraints = []
210  	    f_constraints.append(np.maximum(opt_buy_book[:, -4]*(np.concatenate(np.matmul(opt_buy_book[:, :-4], np.zeros((num_stock, 1))))-opt_buy_book[:, -3]), 0))
211  	    f_constraints.append(np.maximum(opt_buy_book[:, -4]*(np.concatenate(np.matmul(opt_buy_book[:, :-4], sys.maxsize*np.ones((num_stock, 1))))-opt_buy_book[:, -3]), 0))
212  	    g_constraints = []
213  	    g_constraints.append(np.maximum(opt_sell_book[:, -4]*(np.concatenate(np.matmul(opt_sell_book[:, :-4], np.zeros((num_stock, 1))))-opt_sell_book[:, -3]), 0))
214  	    g_constraints.append(np.maximum(opt_sell_book[:, -4]*(np.concatenate(np.matmul(opt_sell_book[:, :-4], sys.maxsize*np.ones((num_stock, 1))))-opt_sell_book[:, -3]), 0))
215  	    sub_obj = 1
216  	
217  	    try:
218  	        # Prime problem
219  	        model = Model("match")
220  	        model.setParam('OutputFlag', False)
221  	
222  	        # Decision variables with liquidity-based upper bounds
223  	        gamma = model.addVars(1, num_buy)  # sell to bid orders
224  	        delta = model.addVars(1, num_sell)  # buy from ask orders
225  	
226  	        # Set upper bounds based on liquidity
227  	        if buy_liquidity is not None:
228  	            for i in range(num_buy):
229  	                if pd.isna(buy_liquidity[i]) or buy_liquidity[i] is None:
230  	                    raise ValueError(f"Buy liquidity value {buy_liquidity[i]} is None or NaN at index {i}")
231  	                elif np.isinf(buy_liquidity[i]):
232  	                    gamma[0, i].ub = 1e6  # Large but finite value
233  	                else:
234  	                    try:
235  	                        gamma[0, i].ub = float(buy_liquidity[i])
236  	                    except (ValueError, TypeError):
237  	                        print(f"Warning: Invalid buy liquidity value {buy_liquidity[i]}. Setting to 1.0")
238  	                        gamma[0, i].ub = 1.0
239  	        else:
240  	            # Default upper bound of 1 if no liquidity specified
241  	            raise ValueError("No liquidity values provided for buy orders")
242  	
243  	        if sell_liquidity is not None:
244  	            for i in range(num_sell):
245  	                if pd.isna(sell_liquidity[i]) or sell_liquidity[i] is None:
246  	                    raise ValueError(f"Sell liquidity value {sell_liquidity[i]} is None or NaN at index {i}")
247  	                elif np.isinf(sell_liquidity[i]):
248  	                    delta[0, i].ub = 1e6  # Large but finite value
249  	                else:
250  	                    try:
251  	                        delta[0, i].ub = float(sell_liquidity[i])
252  	                    except (ValueError, TypeError):
253  	                        print(f"Warning: Invalid sell liquidity value {sell_liquidity[i]}. Setting to 1.0")
254  	                        delta[0, i].ub = 1.0
255  	        else:
256  	            # Default upper bound of 1 if no liquidity specified
257  	            raise ValueError("No liquidity values provided for sell orders")
258  	
259  	        # Add offset variable if needed
260  	        if offset:
261  	            L = model.addVars(1, 1, lb=-GRB.INFINITY, ub=GRB.INFINITY)  # Bounded instead of infinity
262  	        else:
263  	            L = model.addVars(1, 1, lb=0, ub=0)  # Fixed at 0 if no offset
264  	
265  	        # Constraint of 0
266  	        buy_sum = sum(delta[0,i]*g_constraints[0][i] for i in range(num_sell))
267  	        sell_sum = sum(gamma[0,i]*f_constraints[0][i] for i in range(num_buy))
268  	        model.addLConstr(sell_sum-buy_sum-L[0,0], GRB.LESS_EQUAL, 0)
269  	
270  	        # Define objective
271  	        expense = sum(delta[0,i]*opt_sell_book[i, -1] for i in range(num_sell))
272  	        gain = sum(gamma[0,i]*opt_buy_book[i, -1] for i in range(num_buy))
273  	        model.setObjective(gain-expense-L[0,0], GRB.MAXIMIZE)
274  	
275  	        # Sub problem
276  	        sub_model = Model("sub_match")
277  	        sub_model.setParam('OutputFlag', False)
278  	        M = 1000000
279  	        s = sub_model.addVars(1, num_stock)
280  	        f = sub_model.addVars(1, num_buy, lb=-GRB.INFINITY)
281  	        g = sub_model.addVars(1, num_sell)
282  	        I = sub_model.addVars(1, num_buy, vtype=GRB.BINARY)
283  	
284  	        for i in range(num_sell):
285  	            sub_model.addLConstr(opt_sell_book[i, -4]*(sum(opt_sell_book[i, j]*s[0,j] for j in range(num_stock))-opt_sell_book[i, -3])-g[0, i], GRB.LESS_EQUAL, 0)
286  	        for i in range(num_buy):
287  	            sub_model.addLConstr(opt_buy_book[i, -4]*(sum(opt_buy_book[i, j]*s[0,j] for j in range(num_stock))-opt_buy_book[i, -3])+M*(1-I[0, i])-f[0, i], GRB.GREATER_EQUAL, 0)
288  	            sub_model.addLConstr(M*I[0, i]-f[0, i], GRB.GREATER_EQUAL, 0)
289  	            sub_model.addLConstr(opt_buy_book[i, -4]*(sum(opt_buy_book[i, j]*s[0,j] for j in range(num_stock))-opt_buy_book[i, -3])+M*(1-I[0, i]), GRB.GREATER_EQUAL, 0)
290  	            sub_model.addLConstr(opt_buy_book[i, -4]*(sum(opt_buy_book[i, j]*s[0,j] for j in range(num_stock))-opt_buy_book[i, -3])-M*I[0, i], GRB.LESS_EQUAL, 0)
291  	
292  	        it = 0
293  	        start = timeit.default_timer()
294  	        while sub_obj > 0.0005:
295  	            # Add newly generated constraint
296  	            buy_sum_new = sum(delta[0,i]*g_constraints[-1][i] for i in range(num_sell))
297  	            sell_sum_new = sum(gamma[0,i]*f_constraints[-1][i] for i in range(num_buy))
298  	            model.addLConstr(sell_sum_new-buy_sum_new-L[0,0], GRB.LESS_EQUAL, 0)
299  	
300  	            try:
301  	                model.optimize()
302  	            except Exception as e:
303  	                print(f"Optimization error in main model: {e}")
304  	                return 0, 0, 0, False, {'buy_book_index': [], 'sell_book_index': []}
305  	
306  	            # Save decision variables from prime problem
307  	            gamma_val = np.array([max(gamma[0, i].x, 0) for i in range(num_buy)])
308  	            delta_val = np.array([max(delta[0, i].x, 0) for i in range(num_sell)])
309  	            L_val = L[0,0].x
310  	
311  	            if debug == 2:
312  	                print(gamma_val)
313  	                print(delta_val)
314  	                print(L_val)
315  	
316  	            # Define sub obj
317  	            sub_model.setObjective(sum(gamma_val[i]*f[0, i] for i in range(num_buy))-sum(delta_val[i]*g[0, i] for i in range(num_sell))-L_val, GRB.MAXIMIZE)
318  	
319  	            try:
320  	                sub_model.optimize()
321  	            except Exception as e:
322  	                print(f"Optimization error in sub model: {e}")
323  	                return 0, 0, 0, False, {'buy_book_index': [], 'sell_book_index': []}
324  	
325  	            if debug > 0:
326  	                if it % 100 == 0:
327  	                    print([s[0, i].x for i in range(num_stock)])
328  	                    print('{}: objective is {} > 0'.format(it, sub_model.objVal))
329  	                if debug == 2:
330  	                    for i in range(num_buy):
331  	                        print('I:', I[0, i].x)
332  	                        print('f:', f[0, i].x)
333  	                    for i in range(num_sell):
334  	                        print('g:', g[0, i].x)
335  	
336  	            # Save decision variables from sub problem
337  	            f_constraints.append(np.array([f[0, i].x for i in range(num_buy)]))
338  	            g_constraints.append(np.array([g[0, i].x for i in range(num_sell)]))
339  	            sub_obj = sub_model.objVal
340  	            it += 1
341  	
342  	        stop = timeit.default_timer()
343  	        time = stop - start
344  	
345  	        # Print matching result
346  	        if debug == 1:
347  	            revenue = 0
348  	            for i in range(num_buy):
349  	                if gamma[0, i].x > 0:
350  	                    revenue += gamma[0,i].x * opt_buy_book[i, -1]
351  	                    print('Sell {} to {}({}{}+{}{},{}) at bid price {}'.format(round(gamma[0,i].x, 4), 'C' if opt_buy_book[i, -4]==1 else 'P', \
352  	                        opt_buy_book[i, 0], s1, opt_buy_book[i, 1], s2, opt_buy_book[i, -3], opt_buy_book[i, -1]))
353  	            for i in range(num_sell):
354  	                if delta[0, i].x > 0:
355  	                    revenue -= delta[0,i].x * opt_sell_book[i, -1]
356  	                    print('Buy {} from {}({}{}+{}{},{}) at ask price {}'.format(round(delta[0,i].x, 4), 'C' if opt_sell_book[i, -4]==1 else 'P', \
357  	                        opt_sell_book[i, 0], s1, opt_sell_book[i, 1], s2, opt_sell_book[i, -3], opt_sell_book[i, -1]))
358  	            print('Revenue at T0 is {}; L is {}; Objective is {} = {}'.format(round(revenue,2), round(L[0,0].x, 2), round(revenue-L[0,0].x, 2), round(model.objVal, 2)))
359  	
360  	    except GurobiError as e:
361  	        print('Error code ' + str(e.errno) + ": " + str(e))
362  	        return 0, 0, 0, False, {'buy_book_index': [], 'sell_book_index': []}
363  	    except AttributeError:
364  	        print('Encountered an attribute error')
365  	        return 0, 0, 0, False, {'buy_book_index': [], 'sell_book_index': []}
366  	
367  	    # Check if model was successfully created and optimized
368  	    if 'model' not in locals() or model is None:
369  	        return 0, 0, 0, False, {'buy_book_index': [], 'sell_book_index': []}
370  	
371  	    # Check for matches
372  	    isMatch = any(delta[0,i].x > 0 for i in range(len(delta))) or any(gamma[0,j].x > 0 for j in range(len(gamma)))
373  	    matched_stock = {'buy_book_index': None, 'sell_book_index': None}
374  	    matched_stock['buy_book_index'] = [buy_book_index[i] for i in range(len(gamma)) if gamma[0, i].x > 0]
375  	    matched_stock['sell_book_index'] = [sell_book_index[i] for i in range(len(delta)) if delta[0, i].x > 0]
376  	
377  	    return time, model.NumConstrs, model.objVal, isMatch, matched_stock
*** AttributeError: 'DataFrame' object has no attribute 'inde'
Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,
             9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
           dtype='int64')
Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,
             9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
           dtype='int64')
    option1  option2  C=Call, P=Put  Strike Price of the Option Times 1000  transaction_type  B/A_price  liquidity
0      -3.0      5.0           -1.0                                  150.0               1.0      68.04        1.0
1       1.0      3.0            1.0                                  411.0               1.0      63.33        1.0
2       5.0     -8.0           -1.0                                  372.0               1.0     460.67        1.0
3       2.0     -1.0           -1.0                                  238.0               1.0      36.19        1.0
4      -2.0      9.0            1.0                                  496.5               1.0     156.18        1.0
5       1.0      7.0            1.0                                  715.0               1.0     186.12        1.0
6       2.0     -1.0           -1.0                                  221.0               1.0      19.82        1.0
7       6.0      5.0            1.0                                 1275.0               1.0     182.73        1.0
8       3.0      1.0            1.0                                  461.0               1.0     107.05        1.0
9       1.0      1.0            1.0                                  263.0               1.0       0.52        1.0
10      4.0      1.0           -1.0                                  740.5               1.0      22.92        1.0
11      3.0      2.0            1.0                                  569.0               1.0     106.16        1.0
12      3.0      1.0           -1.0                                  622.5               1.0      53.02        1.0
13      2.0     -1.0           -1.0                                  190.5               1.0       2.35        1.0
14      1.0     -2.0           -1.0                                    6.0               1.0      65.73        1.0
15      7.0      6.0            1.0                                 1348.0               1.0     371.95        1.0
16      2.0      1.0           -1.0                                  347.0               1.0       0.02        1.0
17      7.0      5.0           -1.0                                 1842.5               1.0     226.09        1.0
18      1.0      1.0           -1.0                                  319.5               1.0      57.90        1.0
19     -2.0      7.0            1.0                                  269.0               1.0     169.38        1.0
20     -5.0      7.0           -1.0                                   20.5               1.0      28.41        1.0
21      1.0      6.0           -1.0                                  878.0               1.0      73.64        1.0
22      4.0      9.0            1.0                                 1420.0               1.0     156.52        1.0
23      5.0     -3.0            1.0                                  353.0               1.0      90.72        1.0
24      8.0      5.0           -1.0                                 1597.0               1.0       0.30        1.0
0       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
1       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
2       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
3       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
4       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
5       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
6       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
7       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
8       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
9       NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
10      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
11      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
12      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
13      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
14      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
15      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
16      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
17      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
18      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
19      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
20      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
21      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
22      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
23      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
24      NaN      NaN            NaN                                    NaN               NaN        NaN        NaN
    option1  option2  C=Call, P=Put  Strike Price of the Option Times 1000  transaction_type  B/A_price  liquidity
0      -3.0      5.0           -1.0                                  150.0               1.0      68.04          1
1       1.0      3.0            1.0                                  411.0               1.0      63.33          1
2       5.0     -8.0           -1.0                                  372.0               1.0     460.67          1
3       2.0     -1.0           -1.0                                  238.0               1.0      36.19          1
4      -2.0      9.0            1.0                                  496.5               1.0     156.18          1
5       1.0      7.0            1.0                                  715.0               1.0     186.12          1
6       2.0     -1.0           -1.0                                  221.0               1.0      19.82          1
7       6.0      5.0            1.0                                 1275.0               1.0     182.73          1
8       3.0      1.0            1.0                                  461.0               1.0     107.05          1
9       1.0      1.0            1.0                                  263.0               1.0       0.52          1
10      4.0      1.0           -1.0                                  740.5               1.0      22.92          1
11      3.0      2.0            1.0                                  569.0               1.0     106.16          1
12      3.0      1.0           -1.0                                  622.5               1.0      53.02          1
13      2.0     -1.0           -1.0                                  190.5               1.0       2.35          1
14      1.0     -2.0           -1.0                                    6.0               1.0      65.73          1
15      7.0      6.0            1.0                                 1348.0               1.0     371.95          1
16      2.0      1.0           -1.0                                  347.0               1.0       0.02          1
17      7.0      5.0           -1.0                                 1842.5               1.0     226.09          1
18      1.0      1.0           -1.0                                  319.5               1.0      57.90          1
19     -2.0      7.0            1.0                                  269.0               1.0     169.38          1
20     -5.0      7.0           -1.0                                   20.5               1.0      28.41          1
21      1.0      6.0           -1.0                                  878.0               1.0      73.64          1
22      4.0      9.0            1.0                                 1420.0               1.0     156.52          1
23      5.0     -3.0            1.0                                  353.0               1.0      90.72          1
24      8.0      5.0           -1.0                                 1597.0               1.0       0.30          1
0       2.0     -3.0           -1.0                                   38.5               0.0      53.73          1
1       3.0      2.0           -1.0                                  821.5               0.0     149.36          1
2       8.0     -7.0            1.0                                  612.5               0.0      11.82          1
3       1.0     -1.0            1.0                                   83.5               0.0       1.03          1
4       1.0      1.0           -1.0                                  217.0               0.0       0.20          1
5       2.0     -3.0           -1.0                                    4.0               0.0      26.17          1
6       8.0     -5.0            1.0                                  530.0               0.0     174.67          1
7       3.0      8.0           -1.0                                 1484.0               0.0     176.88          1
8      -1.0      8.0            1.0                                  356.5               0.0     340.83          1
9       2.0      1.0           -1.0                                  337.0               0.0       0.21          1
10     -1.0      7.0            1.0                                  494.0               0.0     101.33          1
11     -4.0      7.0            1.0                                  143.0               0.0      30.24          1
12      1.0      1.0           -1.0                                  180.5               0.0       0.03          1
13      6.0      1.0           -1.0                                  976.5               0.0      10.59          1
14      5.0     -1.0            1.0                                  726.5               0.0       4.05          1
15      1.0      4.0            1.0                                  454.5               0.0     124.20          1
16      2.0      1.0           -1.0                                  371.5               0.0       1.24          1
17      6.0      5.0            1.0                                 1520.0               0.0      13.98          1
18      2.0      1.0           -1.0                                  438.0               0.0      26.91          1
19      8.0     -1.0            1.0                                  825.5               0.0     296.32          1
20      2.0     -1.0            1.0                                  274.5               0.0       0.15          1
21      4.0      7.0            1.0                                 1308.0               0.0      69.58          1
22      3.0      1.0           -1.0                                  678.5               0.0     111.87          1
23      8.0     -3.0           -1.0                                  779.5               0.0       9.87          1
24      9.0     -2.0            1.0                                  745.0               0.0     423.79          1
Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,
             9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
           dtype='int64')
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(93)apply_mechanism()
-> time, num_model_Constraints, profit, isMatch, matched_order_index = self.mechanism_solver(orders, offset=offset)
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(79)check_match()
-> is_match, profit = self.apply_mechanism(orders, offset=offset)
 74  	        '''
 75  	        Check if the orders are matched
 76  	        '''
 77  	        if orders is None:
 78  	            orders = self.opt_order
 79  ->	        is_match, profit = self.apply_mechanism(orders, offset=offset)
 80  	        print('checking match', is_match, profit)
 81  	        return is_match, profit
 82  	
 83  	    def apply_mechanism(self, orders : pd.DataFrame, offset : bool = True, show_matched_orders : bool = False):
 84  	        '''
Int64Index([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16,
            17, 18, 19, 20, 21, 22, 23, 24,  0,  1,  2,  3,  4,  5,  6,  7,  8,
             9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24],
           dtype='int64')
> /common/home/hg343/Research/accelerate_combo_option/src/combo_stock_frontier_data_preprocessor_forked.py(159)<module>()
-> is_match, profit = market.check_match()
154  	                        column_names = ['option1', 'option2', 'C=Call, P=Put','Strike Price of the Option Times 1000', 'transaction_type','B/A_price']
155  	                        opt_buy_book_df = pd.DataFrame(opt_buy_book, columns = column_names)
156  	                        opt_sell_book_df = pd.DataFrame(opt_sell_book, columns = column_names)
157  	                        breakpoint()
158  	                        market = Market(pd.concat([opt_buy_book_df, opt_sell_book_df], ignore_index=False),mechanism_solver=mechanism_solver_combo)
159  ->	                        is_match, profit = market.check_match()
160  	                        if is_match:
161  	                            market.remove_matched_orders()
162  	                        #handle multi-threading
163  	                        frontier_option_label = market.epsilon_frontierGeneration(offset = args.offset)
164  	
  1  	import pdb
  2  	import pickle
  3  	import argparse
  4  	import pandas as pd
  5  	import numpy as np
  6  	import random
  7  	import math
  8  	import os.path
  9  	from combinatorial.gen_synthetic_combo_options import gen_synthetic_combo_options
 10  	from combinatorial.synthetic_combo_mip_match import synthetic_combo_match_mip
 11  	from mechanism_solver import mechanism_solver_combo
 12  	from gurobipy import *
 13  	import timeit
 14  	from copy import deepcopy
 15  	from tqdm import tqdm
 16  	# Run in a separate process with timeout
 17  	from multiprocessing import Process, Queue, Pool
 18  	import multiprocessing as mp
 19  	import queue
 20  	import traceback
 21  	from contextlib import contextmanager
 22  	import signal
 23  	import sys
 24  	from multiprocessing import Pool, TimeoutError
 25  	import itertools
 26  	import wandb
 27  	import os
 28  	from market import Market
 29  	
 30  	# Add this function to parse command line arguments
 31  	def parse_arguments():
 32  	    parser = argparse.ArgumentParser(description='Process stock options.')
 33  	    parser.add_argument('--num_stocks', type=int, default=2, help='Number of stocks to process (default: 3)')
 34  	    parser.add_argument('--market_size', type=int, default=50, help='Number of orders in the market')
 35  	    parser.add_argument('--offset', type=bool, default=False, help='Whether to allow offset for liability in the optimization')
 36  	    parser.add_argument('--wandb_project', type=str, default='expediating_comb_financial_market_matching', help='Wandb project name')
 37  	    parser.add_argument('--num_orders', type=int, default=5000, help='number of orders in the orderbook')
 38  	    parser.add_argument('--noise', type=float, default=2**-6, help='noise level in the orderbook')
 39  	    return parser.parse_args()
 40  	
 41  	# Move the main execution code inside if __name__ == '__main__':
 42  	args = parse_arguments()
 43  	
 44  	
 45  	
 46  	# Set wandb API key programmatically
 47  	os.environ["WANDB_API_KEY"] = "d1cb0d609d7b64218fe82a45a54e57f47e2d26da"
 48  	
 49  	try:
 50  	    wandb.login()  # This will now use the API key we just set
 51  	except wandb.errors.AuthError:
 52  	    print("Could not authenticate with wandb. Invalid API key")
 53  	    sys.exit(1)
 54  	
 55  	def signal_handler(signum, frame):
 56  	    print("Ctrl+C received. Terminating processes...")
 57  	    if 'pool' in globals():
 58  	        pool.terminate()
 59  	        pool.join()
 60  	    sys.exit(1)
 61  	
 62  	# Register the signal handler
 63  	signal.signal(signal.SIGINT, signal_handler)
 64  	
 65  	
 66  	
 67  	
 68  	
 69  	
 70  	def add_noise_orderbook(opt_book, NOISE=0.01):
 71  	    SEED = 1
 72  	    random.seed(SEED)
 73  	    # coeff up to len(stock_list); call/put; strike; buy/sell; price (bid/ask)
 74  	    opt_buy_book, opt_sell_book = opt_book[opt_book[:, -2]==1], opt_book[opt_book[:, -2]==0]
 75  	    num_buy, num_sell = len(opt_buy_book), len(opt_sell_book)
 76  	    # add noise
 77  	    buy_noise = [random.random()*NOISE+1 for i in range(num_buy)]
 78  	    opt_buy_book[:, -1] = np.round(buy_noise * opt_buy_book[:, -1], 2)
 79  	    sell_noise = [1-random.random()*NOISE for i in range(num_sell)]
 80  	    opt_sell_book[:, -1] = np.round(sell_noise * opt_sell_book[:, -1], 2)
 81  	    print('There are {} buy orders and {} sell orders'.format(num_buy, num_sell))
 82  	    return opt_buy_book, opt_sell_book
 83  	
 84  	
 85  	
 86  	@contextmanager
 87  	def pool_context(*args, **kwargs):
 88  	    pool = mp.Pool(*args, **kwargs)
 89  	    try:
 90  	        yield pool
 91  	    finally:
 92  	        pool.terminate()
 93  	        pool.join()
 94  	
 95  	# Parameter lists
 96  	# NUM_STOCK_LIST = [2] #, 4, 8, 12, 16, 20]  # 12, 16, 20
 97  	# BOOK_SIZE_LIST = [50] #,150, 200, 250, 300, 350, 400]
 98  	# NOISE_LIST = [2**-6]#[2**-7, 2**-6, 2**-5, 2**-4, 2**-3]
 99  	
100  	
101  	
102  	if __name__ == '__main__':
103  	    NUM_STOCK = args.num_stocks
104  	    MARKET_SIZE = args.market_size
105  	    NOISE = args.noise
106  	    BOOK_SIZE = args.market_size
107  	    NOISE = args.noise
108  	# Create a new pool for each iteration
109  	    tasks = {}
110  	    # directory_path = f'/common/home/hg343/Research/accelerate_combo_option/data/combo_{NUM_STOCK}_frontier_no_offset'
111  	    directory_path = f'/common/home/hg343/Research/accelerate_combo_option/data/combo_2_test'
112  	    with pool_context(processes=20) as pool:
113  	        try:
114  	            with wandb.init(
115  	                project=args.wandb_project,
116  	                name = f"combo_frontier_num_stock_{NUM_STOCK}_noise_{NOISE}_market_size_{MARKET_SIZE}",
117  	            ) as run:
118  	                #turn off random selection for now
119  	                selection = ['AAPL', 'AXP', 'BA', 'DIS', 'GS', 'HD', 'IBM', 'JNJ', 'JPM', 'KO', 'MCD', 'MMM', 'MSFT', 'NKE', 'PG', 'RTX', 'VZ', 'WBA', 'WMT', 'XOM']
120  	                combinations = list(itertools.combinations(selection,NUM_STOCK))
121  	                stock_list= list(random.choice(combinations))
122  	                stock_list = ['AAPL', 'MSFT']
123  	                combinations_string = '_'.join(stock_list)
124  	                for i in range(2,14):
125  	                    filename = f'combinatorial/book/STOCK_2_SEED_{i}_book_{combinations_string}.npy'
126  	                    if os.path.isfile(filename):
127  	                        opt_book = np.load(filename)
128  	                    else:
129  	                        print('File not found')
130  	                        opt_book, stock_list = gen_synthetic_combo_options(NUM_ST=NUM_STOCK, NUM_ORDER=args.num_orders, combinations= stock_list,SEED=i)
131  	                        np.save(filename, opt_book)
132  	                    num_books = len(opt_book)//50
133  	                    # Create artifact once before the loop
134  	                    artifact = wandb.Artifact(
135  	                        name=f"combo_frontier_{'_'.join(stock_list)}_size_{BOOK_SIZE}_noise_{NOISE}",
136  	                        type="dataset",
137  	                        description="Collection of frontier options training data for different markets",
138  	                        metadata={
139  	                            'num_stock': NUM_STOCK,
140  	                            'stock_name': '_'.join(stock_list),
141  	                            'noise': NOISE,
142  	                            'book_size': BOOK_SIZE,
143  	                            'total_markets': num_books  # Add total number of markets
144  	                        }
145  	                    )
146  	                    for market_index in tqdm(range(0,num_books), desc=f'Generating frontier for markets'):
147  	                        stock_name = '_'.join(stock_list)
148  	                        opt_book_1 = opt_book[market_index*MARKET_SIZE:(market_index+1)*MARKET_SIZE]
149  	                        opt_buy_book, opt_sell_book = add_noise_orderbook(opt_book_1, NOISE)
150  	                        print('#####Generating {} with size {} and noise {}#####'.format(filename, BOOK_SIZE, NOISE))
151  	                                # Add debug print before async
152  	                        print(f"Starting async computation for iteration {market_index}")
153  	                        filename = f'corrected_testing_combo_frontier_market_index_{market_index}_book_size_{BOOK_SIZE}_{stock_name}_NOISE_{NOISE}'
154  	                        column_names = ['option1', 'option2', 'C=Call, P=Put','Strike Price of the Option Times 1000', 'transaction_type','B/A_price']
155  	                        opt_buy_book_df = pd.DataFrame(opt_buy_book, columns = column_names)
156  	                        opt_sell_book_df = pd.DataFrame(opt_sell_book, columns = column_names)
157  	                        breakpoint()
158  	                        market = Market(pd.concat([opt_buy_book_df, opt_sell_book_df], ignore_index=False),mechanism_solver=mechanism_solver_combo)
159  ->	                        is_match, profit = market.check_match()
160  	                        if is_match:
161  	                            market.remove_matched_orders()
162  	                        #handle multi-threading
163  	                        frontier_option_label = market.epsilon_frontierGeneration(offset = args.offset)
164  	
165  	                        try:
166  	                            print(f"Result type for iteration {market_index}: {type(frontier_option_label)}")
167  	                            if frontier_option_label is not None:
168  	                                print(f"Successfully completed iteration {market_index}")
169  	                                if not os.path.exists(directory_path):
170  	                                    os.makedirs(directory_path)
171  	
172  	                                stock_name = '_'.join(stock_list)
173  	                                save_path = os.path.join(directory_path, filename+'.pkl')
174  	
175  	                                print(f"Attempting to save to: {save_path}")
176  	                                metadata = {
177  	                                    'num_stock': NUM_STOCK,
178  	                                    'stock_name': stock_name,
179  	                                    'noise': NOISE,
180  	                                    'book_size': BOOK_SIZE,
181  	                                    'market_index': market_index
182  	                                }
183  	                                with open(save_path, 'wb') as f:
184  	                                    pickle.dump(frontier_option_label, f)
185  	                                # Log metadata for this specific market
186  	                                wandb.log({
187  	                                    f'market_{market_index}/metadata': metadata
188  	                                })
189  	
190  	                                # Add this market's file to the artifact
191  	                                artifact.add_file(save_path, name=f'{filename}.pkl')
192  	                                print(f"Successfully saved iteration {market_index}")
193  	                            else:
194  	                                print(f"Iteration {market_index} returned None")
195  	
196  	                        except TimeoutError:
197  	                            print(f"Iteration {market_index} timed out after 20 seconds")
198  	                            # Pool will be automatically cleaned up when the context exits
199  	                            continue
200  	
201  	                # After the loop is complete, log the artifact once with all files
202  	                run.log_artifact(artifact)
203  	
204  	        except Exception as e:
205  	            print(f"Error in main: {str(e)}")
206  	            traceback.print_exc()
Generating frontier for markets:   0%|                                                                      | 0/20 [15:41<?, ?it/s]
Traceback (most recent call last):
  File "/common/home/hg343/Research/accelerate_combo_option/src/combo_stock_frontier_data_preprocessor_forked.py", line 159, in <module>
    is_match, profit = market.check_match()
  File "/common/home/hg343/Research/accelerate_combo_option/src/market.py", line 79, in check_match
    is_match, profit = self.apply_mechanism(orders, offset=offset)
  File "/common/home/hg343/Research/accelerate_combo_option/src/market.py", line 93, in apply_mechanism
    time, num_model_Constraints, profit, isMatch, matched_order_index = self.mechanism_solver(orders, offset=offset)
  File "/common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py", line 188, in mechanism_solver_combo
    assert len(set(buy_book_index) & set(sell_book_index)) == 0, "buy and sell book index should not have any shared index"
  File "/common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py", line 188, in mechanism_solver_combo
    assert len(set(buy_book_index) & set(sell_book_index)) == 0, "buy and sell book index should not have any shared index"
  File "/common/home/hg343/anaconda3/lib/python3.9/bdb.py", line 88, in trace_dispatch
    return self.dispatch_line(frame)
  File "/common/home/hg343/anaconda3/lib/python3.9/bdb.py", line 113, in dispatch_line
    if self.quitting: raise BdbQuit
bdb.BdbQuit
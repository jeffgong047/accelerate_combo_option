
Generating frontier for markets:   0%|                                                                 | 0/20 [00:00<?, ?it/s]
There are 25 buy orders and 25 sell orders
#####Generating market 0 with size 50 and noise 0.015625#####
Starting computation for iteration 0
Set parameter Username
Academic license - for non-commercial use only - expires 2025-11-08
checking match True 10.303087110713317
checking match False -0.0
Processing order 0 (1/37)
checking match False -0.0
quote_price: 69.50942087657864, original_price: 68.04
Processing order 1 (2/37)
Generating frontier for markets:   0%|                                                                 | 0/20 [00:00<?, ?it/s]/common/home/hg343/Research/accelerate_combo_option/src/market.py:280: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.
  frontier_labels = pd.Series(None, index=orders.index)
quote_price: 62.48707286113185, original_price: 63.33
Processing order 3 (3/37)
checking match False -0.0
quote_price: 34.511693024402106, original_price: 36.19
Processing order 4 (4/37)
checking match False -0.0
quote_price: 154.9203211239339, original_price: 156.18
Processing order 5 (5/37)
checking match False -0.0
quote_price: 182.322830549896, original_price: 186.12
Processing order 6 (6/37)
checking match False -0.0
quote_price: 18.90034230810692, original_price: 19.82
Processing order 7 (7/37)
checking match False -0.0
quote_price: 180.87296302568814, original_price: 182.73
Processing order 8 (8/37)
checking match False -0.0
quote_price: 105.08140564471498, original_price: 107.05
Processing order 9 (9/37)
checking match False -0.0
quote_price: -0.0, original_price: 0.52
Processing order 10 (10/37)
checking match False -0.0
quote_price: 15.201653626839953, original_price: 22.92
Processing order 11 (11/37)
checking match False -0.0
quote_price: 104.6923329186927, original_price: 106.16
Processing order 12 (12/37)
checking match False -0.0
quote_price: 51.57869766513667, original_price: 53.02
Processing order 13 (13/37)
checking match False -0.0
quote_price: -0.0, original_price: 2.35
Processing order 14 (14/37)
checking match False -0.0
Encountered an attribute error
quote_price: 0, original_price: 65.73
Processing order 16 (15/37)
checking match False -0.0
quote_price: -0.0, original_price: 0.02
Processing order 17 (16/37)
checking match False -0.0
quote_price: 222.8740224606763, original_price: 226.09
Processing order 18 (17/37)
checking match False -0.0
quote_price: 55.9843771268775, original_price: 57.9
Processing order 19 (18/37)
checking match False -0.0
quote_price: 169.4620698518357, original_price: 169.38
Processing order 20 (19/37)
checking match False -0.0
quote_price: 32.276528696461384, original_price: 28.41
Processing order 21 (20/37)
checking match False -0.0
quote_price: 77.16105947573753, original_price: 73.64
Processing order 22 (21/37)
checking match False -0.0
quote_price: 155.80588433464325, original_price: 156.52
Processing order 23 (22/37)
checking match False -0.0
quote_price: 89.38759856041953, original_price: 90.72
Processing order 24 (23/37)
checking match False -0.0
quote_price: -0.0, original_price: 0.3
Processing order 25 (24/37)
checking match False -0.0
Index([      0,       1,       3,       4,       5,       6,       7,       8,
             9,      10,      11,      12,      13,      14,      16,      17,
            18,      19,      20,      21,      22,      23,      24, 'quote'],
      dtype='object')
Index([26, 27, 28, 31, 32, 36, 38, 39, 41, 42, 43, 46, 48, 'quote'], dtype='object')
> /common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py(192)mechanism_solver_combo()
-> raise
187  	        assert len(set(buy_book_index) & set(sell_book_index)) == 0, "buy and sell book index should not have any shared index"
188  	    except:
189  	        print(buy_book_index)
190  	        print(sell_book_index)
191  	        breakpoint()
192  ->	        raise
193  	    # Extract liquidity values before converting to numpy arrays
194  	    buy_liquidity = None
195  	    sell_liquidity = None
196  	    if 'liquidity' in buy_orders.columns:
197  	        buy_liquidity = buy_orders['liquidity'].values
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(99)run_mechanism_with_timeout()
-> time, num_model_Constraints, profit, isMatch, matched_order_index = mechanism_solver(orders, offset=offset)
 94  	            pool.join()
 95  	
 96  	    def run_mechanism_with_timeout(self, mechanism_solver, orders, offset=True, show_matched_orders=False):
 97  	        try:
 98  	            if mechanism_solver == mechanism_solver_combo:
 99  ->	                time, num_model_Constraints, profit, isMatch, matched_order_index = mechanism_solver(orders, offset=offset)
100  	                if show_matched_orders:
101  	                    return isMatch, profit, matched_order_index
102  	                else:
103  	                    return isMatch, profit
104  	            elif mechanism_solver == mechanism_solver_single:
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(132)apply_mechanism()
-> result = self.run_mechanism_with_timeout(
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(251)priceQuote()
-> is_match, objVal = self.apply_mechanism(market_orders, offset)
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(305)frontierGeneration()
-> quote_price = self.priceQuote(order, temp_orders, offset=offset)
271  	    def frontierGeneration(self, orders : pd.DataFrame = None, epsilon : bool = False, offset : bool = True):
272  	        '''
273  	        Generate the frontier of options with epsilon price quote and constraints
274  	        '''
275  	        if orders is None:
276  	            orders = self.opt_order.copy()
277  	        else:
278  	            orders = orders.copy()
279  	
280  	        frontier_labels = pd.Series(None, index=orders.index)
281  	        try:
282  	            for original_index, row_series in orders.iterrows():
283  	                try:
284  	                    print(f"Processing order {original_index} ({orders.index.get_loc(original_index)+1}/{len(orders)})")
285  	
286  	                    temp_orders = orders.copy()
287  	                    order = row_series.to_frame().T
288  	
289  	                    original_price = row_series['B/A_price']
290  	                    if original_price <= 1e-6:
291  	                        print('Invalid original price')
292  	                        frontier_labels[original_index] = None
293  	                        continue
294  	
295  	                    order.index = ['quote']
296  	                    order['liquidity'] = 1
297  	
298  	                    if epsilon:
299  	                        temp_orders.loc[:, 'liquidity'] = np.inf
300  	
301  	                    temp_orders.loc[original_index, 'B/A_price'] = None
302  	                    temp_orders.drop(original_index, inplace=True)
303  	
304  	                    try:
305  ->	                        quote_price = self.priceQuote(order, temp_orders, offset=offset)
306  	                    except TimeoutError:
307  	                        print(f"Timeout in price quote for order {original_index}")
308  	                        frontier_labels[original_index] = None
309  	                        continue
310  	                    except Exception as e:
311  	                        print(f"Error in price quote for order {original_index}: {e}")
312  	                        frontier_labels[original_index] = None
313  	                        continue
314  	
315  	                    if quote_price is None:
316  	                        print(f"No valid quote price for order {original_index}")
317  	                        frontier_labels[original_index] = None
318  	                        continue
319  	
320  	                    print(f'quote_price: {quote_price}, original_price: {original_price}')
321  	
322  	                    # Compare with the original price
323  	                    if row_series['transaction_type'] == 1:  # Buy order
324  	                        if original_price > quote_price:
325  	                            frontier_labels[original_index] = 1
326  	                        else:
327  	                            frontier_labels[original_index] = 0
328  	                    else:  # Sell order
329  	                        if original_price > quote_price:
330  	                            frontier_labels[original_index] = 1
331  	                        else:
332  	                            frontier_labels[original_index] = 0
333  	
334  	                except TimeoutError:
335  	                    print(f"Timeout processing order {original_index}")
336  	                    frontier_labels[original_index] = None
337  	                except Exception as e:
338  	                    print(f"Error processing order {original_index}: {e}")
339  	                    frontier_labels[original_index] = None
340  	
341  	        except KeyboardInterrupt:
342  	            print("\nProcess interrupted by user. Returning partial results...")
343  	
344  	        orders['belongs_to_frontier'] = frontier_labels
345  	        print(orders)
346  	        return orders
Index(['quote'], dtype='object')
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(251)priceQuote()
-> is_match, objVal = self.apply_mechanism(market_orders, offset)
Index([      0,       1,       3,       4,       5,       6,       7,       8,
             9,      10,      11,      12,      13,      14,      16,      17,
            18,      19,      20,      21,      22,      23,      24,      26,
            27,      28,      31,      32,      36,      38,      39,      41,
            42,      43,      46,      48, 'quote', 'quote'],
      dtype='object')
184  	    def priceQuote(self, option_to_quote : pd.DataFrame, orders_in_market : pd.DataFrame = None, liquidity: pd.Series = None, offset: bool = True):
185  	        '''
186  	        Generate the price of of given input order w.r.t orders in the market
187  	        '''
188  	        assert len(option_to_quote.index) == 1, "option_to_quote should have only one row"
189  	        if orders_in_market is None:
190  	            market_orders = self.get_market_data_order_format()
191  	        else:
192  	            market_orders = orders_in_market.copy()
193  	
194  	        try:
195  	            # Check for infinite liquidity properly
196  	            is_match, profit = self.check_match(market_orders, offset=offset)
197  	            if is_match and (market_orders['liquidity'] == np.inf).any():
198  	                print(f"The market is matched, but contains infinite liquidity, cant get price quote")
199  	                return None
200  	
201  	            if option_to_quote.index[0] != 'quote':
202  	                option_to_quote.index = ['quote']
203  	
204  	            # Check if the specific index value is in market_orders.index
205  	            assert option_to_quote.index[0] not in market_orders.index, "option_to_quote is already in the market"
206  	
207  	            # Use iloc to access the first row regardless of index
208  	            if option_to_quote.iloc[0]['transaction_type'] == 1:
209  	                # quoting price for buy order, we want to quote price by adding a sell order with premium = 0 to the sell side of the market
210  	                new_sell_order = option_to_quote.copy()
211  	                new_sell_order.iloc[0, new_sell_order.columns.get_loc('transaction_type')] = 0
212  	                new_sell_order.iloc[0, new_sell_order.columns.get_loc('B/A_price')] = 0
213  	
214  	                # Handle liquidity column
215  	                if 'liquidity' in new_sell_order.columns:
216  	                    if 'liquidity' in option_to_quote.columns:
217  	                        new_sell_order.iloc[0, new_sell_order.columns.get_loc('liquidity')] = option_to_quote.iloc[0]['liquidity']
218  	                    else:
219  	                        new_sell_order.iloc[0, new_sell_order.columns.get_loc('liquidity')] = 1
220  	                else:
221  	                    new_sell_order['liquidity'] = 1
222  	
223  	                market_orders = pd.concat([market_orders, new_sell_order], ignore_index=False)
224  	                try:
225  	                    is_match, objVal = self.apply_mechanism(market_orders, offset)
226  	                    return objVal
227  	                except TimeoutError:
228  	                    print("Timeout in mechanism solver for buy order quote")
229  	                    raise
230  	                except Exception as e:
231  	                    print(f"Error in mechanism solver for buy order quote: {e}")
232  	                    return None
233  	
234  	            elif option_to_quote.iloc[0]['transaction_type'] == 0:
235  	                # quoting price for sell order, we want to quote price by adding a buy order with premium = max price to the buy side of the market
236  	                new_buy_order = option_to_quote.copy()
237  	                new_buy_order.iloc[0, new_buy_order.columns.get_loc('transaction_type')] = 1
238  	                new_buy_order.iloc[0, new_buy_order.columns.get_loc('B/A_price')] = sys.maxsize
239  	
240  	                # Handle liquidity column
241  	                if 'liquidity' in new_buy_order.columns:
242  	                    if 'liquidity' in option_to_quote.columns:
243  	                        new_buy_order.iloc[0, new_buy_order.columns.get_loc('liquidity')] = option_to_quote.iloc[0]['liquidity']
244  	                    else:
245  	                        new_buy_order.iloc[0, new_buy_order.columns.get_loc('liquidity')] = 1
246  	                else:
247  	                    new_buy_order['liquidity'] = 1
248  	
249  	                market_orders = pd.concat([market_orders, new_buy_order, option_to_quote], ignore_index=False)
250  	                try:
251  ->	                    is_match, objVal = self.apply_mechanism(market_orders, offset)
252  	                    if is_match:
253  	                        return sys.maxsize - objVal
254  	                    else:
255  	                        return None
256  	                except TimeoutError:
257  	                    print("Timeout in mechanism solver for sell order quote")
258  	                    raise
259  	                except Exception as e:
260  	                    print(f"Error in mechanism solver for sell order quote: {e}")
261  	                    return None
262  	            else:
263  	                raise ValueError("Invalid transaction type")
264  	
265  	        except TimeoutError:
266  	            raise  # Re-raise timeout to be handled by caller
267  	        except Exception as e:
268  	            print(f"Error in price quote: {e}")
269  	            return None
Index([      0,       1,       3,       4,       5,       6,       7,       8,
             9,      10,      11,      12,      13,      14,      16,      17,
            18,      19,      20,      21,      22,      23,      24,      26,
            27,      28,      31,      32,      36,      38,      39,      41,
            42,      43,      46,      48, 'quote', 'quote'],
      dtype='object')
Index(['quote'], dtype='object')
Index(['quote'], dtype='object')
> /common/home/hg343/Research/accelerate_combo_option/src/market.py(305)frontierGeneration()
-> quote_price = self.priceQuote(order, temp_orders, offset=offset)
271  	    def frontierGeneration(self, orders : pd.DataFrame = None, epsilon : bool = False, offset : bool = True):
272  	        '''
273  	        Generate the frontier of options with epsilon price quote and constraints
274  	        '''
275  	        if orders is None:
276  	            orders = self.opt_order.copy()
277  	        else:
278  	            orders = orders.copy()
279  	
280  	        frontier_labels = pd.Series(None, index=orders.index)
281  	        try:
282  	            for original_index, row_series in orders.iterrows():
283  	                try:
284  	                    print(f"Processing order {original_index} ({orders.index.get_loc(original_index)+1}/{len(orders)})")
285  	
286  	                    temp_orders = orders.copy()
287  	                    order = row_series.to_frame().T
288  	
289  	                    original_price = row_series['B/A_price']
290  	                    if original_price <= 1e-6:
291  	                        print('Invalid original price')
292  	                        frontier_labels[original_index] = None
293  	                        continue
294  	
295  	                    order.index = ['quote']
296  	                    order['liquidity'] = 1
297  	
298  	                    if epsilon:
299  	                        temp_orders.loc[:, 'liquidity'] = np.inf
300  	
301  	                    temp_orders.loc[original_index, 'B/A_price'] = None
302  	                    temp_orders.drop(original_index, inplace=True)
303  	
304  	                    try:
305  ->	                        quote_price = self.priceQuote(order, temp_orders, offset=offset)
306  	                    except TimeoutError:
307  	                        print(f"Timeout in price quote for order {original_index}")
308  	                        frontier_labels[original_index] = None
309  	                        continue
310  	                    except Exception as e:
311  	                        print(f"Error in price quote for order {original_index}: {e}")
312  	                        frontier_labels[original_index] = None
313  	                        continue
314  	
315  	                    if quote_price is None:
316  	                        print(f"No valid quote price for order {original_index}")
317  	                        frontier_labels[original_index] = None
318  	                        continue
319  	
320  	                    print(f'quote_price: {quote_price}, original_price: {original_price}')
321  	
322  	                    # Compare with the original price
323  	                    if row_series['transaction_type'] == 1:  # Buy order
324  	                        if original_price > quote_price:
325  	                            frontier_labels[original_index] = 1
326  	                        else:
327  	                            frontier_labels[original_index] = 0
328  	                    else:  # Sell order
329  	                        if original_price > quote_price:
330  	                            frontier_labels[original_index] = 1
331  	                        else:
332  	                            frontier_labels[original_index] = 0
333  	
334  	                except TimeoutError:
335  	                    print(f"Timeout processing order {original_index}")
336  	                    frontier_labels[original_index] = None
337  	                except Exception as e:
338  	                    print(f"Error processing order {original_index}: {e}")
339  	                    frontier_labels[original_index] = None
340  	
341  	        except KeyboardInterrupt:
342  	            print("\nProcess interrupted by user. Returning partial results...")
343  	
344  	        orders['belongs_to_frontier'] = frontier_labels
345  	        print(orders)
346  	        return orders
Process error:
Error in mechanism solver: Mechanism solver failed
Error in mechanism solver for sell order quote: Mechanism solver failed
No valid quote price for order 25
Processing order 26 (25/37)
Traceback (most recent call last):
  File "/common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py", line 187, in mechanism_solver_combo
    assert len(set(buy_book_index) & set(sell_book_index)) == 0, "buy and sell book index should not have any shared index"
AssertionError: buy and sell book index should not have any shared index
During handling of the above exception, another exception occurred:
Traceback (most recent call last):
  File "/common/home/hg343/Research/accelerate_combo_option/src/market.py", line 99, in run_mechanism_with_timeout
    time, num_model_Constraints, profit, isMatch, matched_order_index = mechanism_solver(orders, offset=offset)
  File "/common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py", line 192, in mechanism_solver_combo
    raise
  File "/common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py", line 192, in mechanism_solver_combo
    raise
  File "/common/home/hg343/anaconda3/lib/python3.9/bdb.py", line 88, in trace_dispatch
    return self.dispatch_line(frame)
  File "/common/home/hg343/anaconda3/lib/python3.9/bdb.py", line 113, in dispatch_line
    if self.quitting: raise BdbQuit
bdb.BdbQuit
checking match False -0.0
Index([      0,       1,       3,       4,       5,       6,       7,       8,
             9,      10,      11,      12,      13,      14,      16,      17,
            18,      19,      20,      21,      22,      23,      24, 'quote'],
      dtype='object')
Index([25, 27, 28, 31, 32, 36, 38, 39, 41, 42, 43, 46, 48, 'quote'], dtype='object')
> /common/home/hg343/Research/accelerate_combo_option/src/mechanism_solver.py(192)mechanism_solver_combo()
-> raise
